\subsection{Integracja z Google Maps Platform}

Głównym elementem aplikacji jest zastosowanie w niej funkcji oferowanych przez Google Maps Platform. Jak wspomniane zostało w rozdziale~\ref{google_cloud}, tworzenie projektu w Firebase
jest jednoznaczne z utworzeniem projektu w Google Cloud Platform. Dzięki temu w konsoli Google Cloud można skorzystać z produktu APIs and Services, aby do projektu aplikacji Android dodać
Maps SDK for Android oraz Directions API.\@ Następnie, wygenerowany w Google Cloud Console klucz API należy dodać do aplikacji Android. Zapewnia to połączenie z usługami Google Maps Platform.

    \subsubsection{Implementacja Maps SDK for Android}
    Google Maps SDK for Android zawiera w sobie podstawowe funkcjonalności związane z wyświetlaniem dynamicznej mapy i interakcji z nią. Głównym ekranem aplikacji jest ekran wyświetlający mapę.
    Implementuje on interfejs programistyczny \emph{OnMapReadyCallback}, który umożliwia wprowadzenie do aplikacji metody nasłuchującej momentu, w którym mapa będzie gotowa do wyświetlenia.
    To właśnie tam konfigurowane są ustawienia mapy i wywoływana jest funkcja znajdująca lokację urządzenia użytkownika. Na Listingu~\ref{map_callback} zaobserwować można proces konfiguracji
    ustawień mapy. W procesie wyszukiwania miejsc na mapie wyświetlone zostają pinezki oznaczające konkretne miejsca. Za pomocą funkcjonalności zaoferowanej przez Maps SDK możliwe jest 
    elastyczne dostosowanie sposobu wyświetlania obiektów na mapie. Proces wyświetlania na mapie pinezki reprezentującej konkretne miejsce można zaobserwować w Listingu~\ref{firebase_get}. \\

    Aby aplikacja mogła wykorzystywać w swoim działaniu informacje o położeniu urządzenia użytkownika, musi on udzielić aplikacji odpowiednich uprawnień.

    \vspace{1cm}
    \begin{lstlisting}[
        language=Kotlin, 
        caption=Konfiguracja ustawień mapy w funkcji \emph{OnMapReadyCallback}, 
        label=map_callback,
    ]
override fun onMapReady(map: GoogleMap) {
// wlaczenie wyswietlania lokacji urzadzenia
// na mapie
map.isMyLocationEnabled = true
map.uiSettings.isMyLocationButtonEnabled = true
map.uiSettings.isCompassEnabled = false
map.isBuildingsEnabled = true
// ustawienie stylu graficznego mapy zdefiniowanego
// w map_style.json
map.setMapStyle(MapStyleOptions.loadRawResourceStyle(
    requireContext(), R.raw.map_style
))
locationButtonSettings()

// ograniczenie mozliwosci przewijania mapy
// do obrebu Wrolawia
val latLngBounds = LatLngBounds(
    LatLng(51.047, 16.936),
    LatLng(51.143, 17.1)
)
map.setLatLngBoundsForCameraTarget(latLngBounds)
// ograniczenie mozliwosci oddalania i przyblizania
// kamery do porzadanych wartosci
map.setMinZoomPreference(MIN_ZOOM)
map.setMaxZoomPreference(MAX_ZOOM)
}
    \end{lstlisting}

    \subsubsection{Implementacja Directions API}
    W przeciwieństwie do API wyświetlającego samą mapę Directions API nie posiada biblioteki dedykowanej dla tworzenia aplikacji na system Android. Oznacza to, że należy skorzystać z innej metody
    wysyłania zapytań to API.\@ W aplikacji została wykorzystana biblioteka Volley. Jest to tworzona przez Google biblioteka przeznaczona do wykonywania zapytań HTTP i łączenia z różnego rodzaju usługami
    sieciowymi~\cite{VOLLEY}. Directions API wykorzystane jest w aplikacji w celu rysowania trasy do wybranego przez użytkownika miejsca lub aby narysować trasę wycieczki, przechodzącą przez wszystkie
    zawarte w niej miejsca. Za pomocą Volley wysyłane jest zapytanie do Directions API, a następnie po otrzymaniu odpowiedzi w postaci drzewa JSON wydobywane są instrukcje potrzebne do narysowania
    wytyczonej ścieżki na widzianej przez użytkownika mapie. Przykładową funkcję wysyłającą zapytanie do API i rysującą ścieżkę prowadzącą z lokacji użytkownika do wybranego miejsca zobaczyć można
    na Listingu~\ref{draw_path}. Directions API wysyła odpowiedź w formie drzewa JSON zawierającego dokładne instrukcje podróży od startu do celu. W zapytaniu można sprecyzować także przystanki,
    przez które przechodzić ma trasa, co zastosowane zostało w przypadku rysowania trasy Wycieczki. Odpowiedź z Directions API składa się z hierarchii elementów: trasy (ang.\@ routes), najwyższy element,
    reprezentuje trasę pomiędzy początkiem a celem, odcinki (ang.\@ legs), trasa pomiędzy przystankami trasy, kroki (ang.\@ steps), najniższe elementy trasy, zawierają konkretne, dokładne instrukcje 
    kierujące~\cite{ROUTES}.

\newpage
    \begin{lstlisting}[
        language=Kotlin, 
        caption=Funkcja pobierająca trasę z Directions API i rysująca ją na mapie, 
        label=draw_path,
    ]
fun drawPathToPlace(
placeLatitude: Double, placeLongitude: Double, placeId: String
) {
// tablica przechowujaca w sobie pozycje przez ktore musi 
// przejsc sciezka prowadzaca do miejsca
val path: MutableList<List<LatLng>> = ArrayList()

// zapytanie wysylane do Directions API
// zawiera w sobie miejsce rozpoczecia i konca trasy
// oraz klucz API laczacy aplikacje z Directions API
val urlDirections =
    "https://maps.googleapis.com/maps/api/directions/json?" +
            "origin=${map.myLocation.latitude}," +
            "${map.myLocation.longitude}&" +
            "destination=${placeLatitude},${placeLongitude}&" +
            "key=AIzaSyCNXAkT-Zg-NY4md_kespycX7fV_ff8KQw"

// wysylanie zapytania i nasluchiwanie odpowiedzi obslugiwane 
// jest przez oferowany przez Volley obiekt StringRequest
val directionsRequest = object : StringRequest(
    Method.GET,
    urlDirections,
    Response.Listener { response ->
        // z obiektu JSON odebranego z API wyciagane sa
        // routes - trasa pomiedzy wybranym poczatkiem i koncem
        val responseJSON = JSONObject(response)
        val routes = responseJSON.getJSONArray("routes")

        // legs - skladowe routes; w jednym obiekie routes
        // znajduje sie leg dla kazdego z przystankow, w tym
        // przypadku jedno.
        val legs = routes.getJSONObject(0).getJSONArray("legs")

        // steps - najnizsza jednostka trasy, okreslajaca  
        // pojedyncza instrukcje trasy
        // pozycje kazdego step dodwane sa do sciezki, ktora 
        // zostanie narysowana
        val steps = legs.getJSONObject(0).getJSONArray("steps")
        for (i in 0 until steps.length()) {
            val points = steps.getJSONObject(i)
            .getJSONObject("polyline").getString("points")
            path.add(PolyUtil.decode(points))
        }

        // petla nanoszaca linie sciezki na mape
        for (i in 0 until path.size) {
            map.addPolyline(PolylineOptions().addAll(path[i])
            .color(Color.rgb(230, 138, 0)))
        }
    },

val requestQueue = Volley.newRequestQueue(requireContext())
requestQueue.add(directionsRequest)
}
    \end{lstlisting}
    \vspace{1cm}